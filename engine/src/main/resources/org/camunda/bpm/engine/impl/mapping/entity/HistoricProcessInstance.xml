<?xml version="1.0" encoding="UTF-8" ?>

<!--
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~       http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="org.camunda.bpm.engine.impl.persistence.entity.HistoricProcessInstanceEntity">
    
  <!-- 
  
  NOTE:
  
  HPIs are stored as update events. For each HPI, there are usually two update 
  events which correspond to two lines in the DB:
     
    * a first line added when the HPI is started
    * a second line added when the HPI is ended  
  
  The first part of this file contains the mappings for these update events. 
  
  When querying the DB, we are usually interested in an aggregated 
  representation which combines the data contained in both update events as an individual 
  object. The second part of this file contains aggregation queries which allows retrieving 
  HPIs as single lines / objects.     
    
  -->
  
  <!-- /////////////////// start mappings for HistoricProcessInstanceEvent //////////////////// -->
    
  <resultMap id="historicProcessInstanceEventResultMap" type="org.camunda.bpm.engine.impl.history.event.HistoricProcessInstanceEventEntity">
    <id property="id" column="ID_" jdbcType="VARCHAR" />
    <result property="processInstanceId" column="PROC_INST_ID_" jdbcType="VARCHAR" />
    <result property="processDefinitionId" column="PROC_DEF_ID_" jdbcType="VARCHAR"/>
    <result property="timestamp" column="TIMESTAMP_" jdbcType="TIMESTAMP" />
    <result property="activityId" column="ACT_ID_" jdbcType="VARCHAR" />
    <result property="eventType" column="EVENT_TYPE_" jdbcType="VARCHAR" />
    <result property="businessKey" column="BUSINESS_KEY_" jdbcType="VARCHAR" />
    <result property="startUserId" column="START_USER_ID_" jdbcType="VARCHAR" />
    <result property="superProcessInstanceId" column="SUPER_PROCESS_INSTANCE_ID_" jdbcType="VARCHAR" />
    <result property="deleteReason" column="DELETE_REASON_" jdbcType="VARCHAR" />
  </resultMap>

  <insert id="insertHistoricProcessInstanceEvent" parameterType="org.camunda.bpm.engine.impl.history.event.HistoricProcessInstanceEventEntity">
      insert into ${prefix}ACT_HI_PROCINST (
        ID_,
        PROC_INST_ID_,
        PROC_DEF_ID_,
        TIMESTAMP_,
        ACT_ID_,        
        EVENT_TYPE_,             
        BUSINESS_KEY_,
        START_USER_ID_,
        SUPER_PROCESS_INSTANCE_ID_,
        DELETE_REASON_
      ) values (
        #{id ,jdbcType=VARCHAR},
        #{processInstanceId, jdbcType=VARCHAR},
        #{processDefinitionId, jdbcType=VARCHAR},
        #{timestamp, jdbcType=TIMESTAMP},
        #{activityId, jdbcType=VARCHAR},
        #{eventType, jdbcType=VARCHAR},        
        #{businessKey, jdbcType=VARCHAR},       
        #{startUserId, jdbcType=VARCHAR},
        #{superProcessInstanceId, jdbcType=VARCHAR},
        #{deleteReason, jdbcType=VARCHAR}
      )
  </insert>
    
  <select id="selectHistoricProcessInstanceEvent" resultMap="historicProcessInstanceEventResultMap">
    SELECT *       
    FROM 
      ${prefix}ACT_HI_PROCINST      
    WHERE 
      ID_ = #{historicProcessInstanceEventId}    
  </select>
  
  <delete id="deleteHistoricProcessInstanceEvent">
    delete from ${prefix}ACT_HI_PROCINST where ID_ = #{id}
  </delete>
  
  <!-- /////////////////// start mappings for HistoricProcessInstance //////////////////// -->
  
  <delete id="deleteHistoricProcessInstanceEntity">
    delete from ${prefix}ACT_HI_PROCINST where PROC_INST_ID_ = #{id}
  </delete>
      
  <!-- HISTORIC PROCESS INSTANCE RESULT MAP -->  
  <!-- this is the aggregated HPI -->
  <resultMap id="historicProcessInstanceResultMap" type="org.camunda.bpm.engine.impl.persistence.entity.HistoricProcessInstanceEntity">
    
    <!-- read from START evt -->
    <id property="id" column="ID_" jdbcType="VARCHAR" />
    <result property="processInstanceId" column="PROC_INST_ID_" jdbcType="VARCHAR" />
    <result property="processDefinitionId" column="PROC_DEF_ID_" jdbcType="VARCHAR" />
    <result property="superProcessInstanceId" column="SUPER_PROCESS_INSTANCE_ID_" jdbcType="VARCHAR" />
    <result property="startTime" column="START_TIME_" jdbcType="TIMESTAMP" />
    <result property="startActivityId" column="START_ACT_ID_" jdbcType="VARCHAR" />
    
    <!-- read from END evt -->
    <result property="businessKey" column="BUSINESS_KEY_" jdbcType="VARCHAR"/>
    <result property="deleteReason" column="DELETE_REASON_" jdbcType="VARCHAR" />
    <result property="startUserId" column="START_USER_ID_" jdbcType="VARCHAR" />
    <result property="endTime" column="END_TIME_" jdbcType="TIMESTAMP" />
    <result property="endActivityId" column="END_ACT_ID_" jdbcType="VARCHAR" />

    <!-- calculated -->
    <result property="durationInMillis" column="DURATION_" jdbcType="BIGINT" />
  </resultMap>
  
  <!-- aggregates HPIE by  -->
  <select id="selectHistoricProcessInstance" resultMap="historicProcessInstanceResultMap">
    SELECT distinct
       P1.PROC_INST_ID_  as ID_,  
       P1.PROC_INST_ID_  as PROC_INST_ID_,
       P2.BUSINESS_KEY_ as BUSINESS_KEY_ ,
       P1.PROC_DEF_ID_ as PROC_DEF_ID_ ,
       P1.TIMESTAMP_ as START_TIME_,
       P2.TIMESTAMP_ as END_TIME_,
       DATEDIFF(ms, P1.TIMESTAMP_ , P2.TIMESTAMP_ ) as DURATION_,
       P1.START_USER_ID_ as START_USER_ID_ ,
       P1.ACT_ID_ as START_ACT_ID_,
       P2.ACT_ID_ as END_ACT_ID_,
       P1.SUPER_PROCESS_INSTANCE_ID_ as SUPER_PROCESS_INSTANCE_ID_,
       P2.DELETE_REASON_  as DELETE_REASON_
        
     FROM
       ${prefix}ACT_HI_PROCINST P1
     LEFT JOIN 
       ${prefix}ACT_HI_PROCINST P2 
       ON 
         P1.PROC_INST_ID_  = P2.PROC_INST_ID_
       AND
         P2.EVENT_TYPE_ = 'end'       
        
     WHERE
       P1.EVENT_TYPE_ = 'start'    
       AND P1.PROC_INST_ID_ = #{processInstanceId}
   </select>
     
  <select id="selectHistoricProcessInstanceIdsByProcessDefinitionId" parameterType="org.camunda.bpm.engine.impl.db.ListQueryParameterObject" resultType="string">
    select distinct PROC_INST_ID_
    from ${prefix}ACT_HI_PROCINST 
    where PROC_DEF_ID_ = #{parameter}
  </select>
  

  <select id="selectHistoricProcessInstancesByQueryCriteria" parameterType="org.camunda.bpm.engine.impl.HistoricProcessInstanceQueryImpl" resultMap="historicProcessInstanceResultMap">
  	${limitBefore}    
    select ${limitBetween}
    
    * FROM (SELECT distinct
    
    P1.PROC_INST_ID_  as ID_,  
    P1.PROC_INST_ID_  as PROC_INST_ID_,
    P2.BUSINESS_KEY_ as BUSINESS_KEY_ ,
    P1.PROC_DEF_ID_ as PROC_DEF_ID_ ,
    P1.TIMESTAMP_ as START_TIME_,
    P2.TIMESTAMP_ as END_TIME_,
    DATEDIFF(ms, P1.TIMESTAMP_ , P2.TIMESTAMP_ ) as DURATION_,
    P1.START_USER_ID_ as START_USER_ID_ ,
    P1.ACT_ID_ as START_ACT_ID_,
    P2.ACT_ID_ as END_ACT_ID_,
    P1.SUPER_PROCESS_INSTANCE_ID_ as SUPER_PROCESS_INSTANCE_ID_,
    P2.DELETE_REASON_  as DELETE_REASON_
    
    <include refid="selectHistoricProcessInstancesByQueryCriteriaSql"/>
    ) RES
    
    ${orderBy}
    ${limitAfter}
  </select>
  
  <select id="selectHistoricProcessInstanceCountByQueryCriteria" parameterType="org.camunda.bpm.engine.impl.HistoricProcessInstanceQueryImpl" resultType="long">
    select count(distinct P1.PROC_INST_ID_)
    <include refid="selectHistoricProcessInstancesByQueryCriteriaSql"/>
  </select>
  
  <sql id="selectHistoricProcessInstancesByQueryCriteriaSql">   
          
    FROM ${prefix}ACT_HI_PROCINST P1
    LEFT JOIN 
       ${prefix}ACT_HI_PROCINST P2 
       ON 
         P1.PROC_INST_ID_  = P2.PROC_INST_ID_
       AND
         P2.EVENT_TYPE_ = 'end'    
            
    <if test="processKeyNotIn != null || processDefinitionKey != null">
      inner join ${prefix}ACT_RE_PROCDEF DEF on P1.PROC_DEF_ID_ = DEF.ID_
    </if>
    <foreach collection="queryVariableValues" index="index" item="queryVariableValue">
      inner join ${prefix}ACT_HI_VARINST  A${index} on P1.PROC_INST_ID_ = A${index}.PROC_INST_ID_
    </foreach>    
    <where>
    
      P1.EVENT_TYPE_ = 'start'
       
      <if test="processInstanceId != null">
        P1.PROC_INST_ID_ = #{processInstanceId}
      </if>
      <if test="processInstanceIds != null and !processInstanceIds.isEmpty()">
        and P1.PROC_INST_ID_ in
        <foreach item="item" index="index" collection="processInstanceIds" open="(" separator="," close=")">
          #{item}
        </foreach>
      </if>
      <if test="processDefinitionId != null">
        and P1.PROC_DEF_ID_ = #{processDefinitionId}
      </if>
      <if test="processDefinitionKey != null">
        and P1.PROC_DEF_ID_ like #{processDefinitionIdLike}
      </if>
      <if test="businessKey != null">
        and P1.BUSINESS_KEY_ = #{businessKey}
      </if>

      <if test="startedBefore != null">
        and P1.TIMESTAMP_ &lt;= #{startedBefore}
      </if>
      <if test="startedAfter != null">
        and P1.TIMESTAMP_ &gt;= #{startedAfter}
      </if>
      <if test="finishedBefore != null">
        and P2.TIMESTAMP_ &lt;= #{finishedBefore}
      </if>
      <if test="finishedAfter != null">
        and P2.TIMESTAMP_ &gt;= #{finishedAfter}
      </if>
      <if test="processKeyNotIn != null">
        <foreach collection="processKeyNotIn" index="index" item="procDefKey">
        and P1.KEY_ not like #{procDefKey}
      </foreach>
      </if>
      
      <!-- DEPRECATED : TO BE REMOVED IN 5.11 -->
      <if test="startDateOn">
        and P1.TIMESTAMP_ &gt;= #{startDateOnBegin}
        and P2.TIMESTAMP_ &lt;= #{startDateOnEnd}
      </if>
      <!-- DEPRECATED : TO BE REMOVED IN 5.11 -->
      <if test="finishDateOn">
        and P1.TIMESTAMP_ &gt;= #{finishDateOnBegin}
        and P2.TIMESTAMP_ &lt;= #{finishDateOnEnd}
      </if>
      <!-- DEPRECATED : TO BE REMOVED IN 5.11 -->
      <if test="finishDateBy">
        and P2.TIMESTAMP_ &lt;= #{finishDateBy}
      </if>
      <!-- DEPRECATED : TO BE REMOVED IN 5.11 -->
      <if test="startDateBy">
        and P1.TIMESTAMP_ &gt;= #{startDateBy}
      </if>

      <if test="unfinished">
        and P2.TIMESTAMP_ IS NULL
      </if>
      <if test="finished">
        and P2.TIMESTAMP_ is not NULL
      </if>
      <if test="startedBy != null">
        and P1.START_USER_ID_ = #{startedBy}
      </if>
      <if test="superProcessInstanceId != null">
        and P1.SUPER_PROCESS_INSTANCE_ID_ = #{superProcessInstanceId}
      </if>
      <foreach collection="queryVariableValues" index="index" item="queryVariableValue">
        and A${index}.NAME_= #{queryVariableValue.name}
        <if test="!queryVariableValue.type.equals('null')">
        <!-- When operator is not-equals or type of value is null, type doesn't matter! -->
          and A${index}.VAR_TYPE_ = #{queryVariableValue.type}
        </if>
        <if test="queryVariableValue.textValue != null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
        and A${index}.TEXT_
        <choose>
          <when test="queryVariableValue.operator.equals('LIKE')">LIKE</when>
          <otherwise><include refid="executionVariableOperator" /></otherwise>
        </choose>
          #{queryVariableValue.textValue}
        </if>
        <if test="queryVariableValue.textValue2 != null">
        and A${index}.TEXT2_
        <choose>
          <when test="queryVariableValue.operator.equals('LIKE')">LIKE</when>
          <otherwise><include refid="executionVariableOperator" /></otherwise>
        </choose>
          #{queryVariableValue.textValue2}
        </if>
        <if test="queryVariableValue.longValue != null">
        and A${index}.LONG_
        <include refid="executionVariableOperator" />
        #{queryVariableValue.longValue}
        </if>
        <if test="queryVariableValue.doubleValue != null">
        and A${index}.DOUBLE_
        <include refid="executionVariableOperator" />
        #{queryVariableValue.doubleValue}
        </if>
        <!-- Null variable type -->
        <if test="queryVariableValue.textValue == null &amp;&amp; queryVariableValue.textValue2 == null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
          <choose>
          <when test="queryVariableValue.operator.equals('NOT_EQUALS')">
            and (A${index}.TEXT_ is not null or A${index}.TEXT2_ is not null or A${index}.LONG_ is not null or A${index}.DOUBLE_ is not null or A${index}.BYTEARRAY_ID_ is not null)
          </when>
          <otherwise>
            and A${index}.TEXT_ is null and A${index}.TEXT2_ is null and A${index}.LONG_ is null and A${index}.DOUBLE_ is null and A${index}.BYTEARRAY_ID_ is null
          </otherwise>
        </choose>
        </if>
      </foreach>
    </where>
  </sql>
  
  <sql id="executionVariableOperator">
    <choose>
      <when test="queryVariableValue.operator.equals('EQUALS')">=</when>
      <when test="queryVariableValue.operator.equals('NOT_EQUALS')">&lt;&gt;</when>
      <when test="queryVariableValue.operator.equals('GREATER_THAN')">&gt;</when>
      <when test="queryVariableValue.operator.equals('GREATER_THAN_OR_EQUAL')">&gt;=</when>
      <when test="queryVariableValue.operator.equals('LESS_THAN')">&lt;</when>
      <when test="queryVariableValue.operator.equals('LESS_THAN_OR_EQUAL')">&lt;=</when>
   </choose>
  </sql>
 
  <select id="selectHistoricProcessInstanceByNativeQuery" parameterType="java.util.Map" resultMap="historicProcessInstanceResultMap">
    <if test="resultType == 'LIST_PAGE'">
      ${limitBefore}
    </if>
    ${sql}
    <if test="resultType == 'LIST_PAGE'">
      ${limitAfter}
    </if>
  </select>
  
  <select id="selectHistoricProcessInstanceByNativeQuery_mssql_or_db2" parameterType="java.util.Map" resultMap="historicProcessInstanceResultMap">
    <if test="resultType == 'LIST_PAGE'">
        ${limitBeforeNativeQuery}
    </if>
    ${sql} 
    <if test="resultType == 'LIST_PAGE'">
      ${limitAfter}
    </if>
  </select>

  <select id="selectHistoricProcessInstanceCountByNativeQuery" parameterType="java.util.Map" resultType="long">
    ${sql}
  </select>
</mapper>
